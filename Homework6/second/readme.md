# Результати:
## Шляхи за допомогою DFS:
```
['A', 'C', 'B', 'D', 'E', 'F']
['A', 'C', 'E', 'F']
['A', 'B', 'D', 'E', 'F']
['A', 'B', 'C', 'E', 'F']
```

## Шляхи за допомогою BFS:
```
['A', 'C', 'E', 'F']
['A', 'B', 'C', 'E', 'F']
['A', 'B', 'D', 'E', 'F']
['A', 'C', 'B', 'D', 'E', 'F']
```


# Аналіз результатів

## DFS (глибинний пошук):
   - DFS шукає шлях у глибину графа. Це означає, що алгоритм рухається вниз по одному шляху, поки не досягне кінця, перш ніж відступити і дослідити інші шляхи.
   - В результаті DFS може знайти шлях, який не є найкоротшим. 
## BFS (ширинний пошук):
   - BFS шукає шлях у ширину графа. Це означає, що алгоритм досліджує всі сусідні вершини на поточному рівні, перш ніж перейти на наступний рівень.
   - В результаті BFS завжди знайде найкоротший шлях (з найменшою кількістю ребер) у незваженому графі.

Порівняння та пояснення:
   - **DFS** шляхи: можуть бути різними і не обов’язково найкоротшими. Це пов’язано з тим, що DFS заглиблюється в граф, досліджуючи один шлях повністю перед переходом до іншого.
   - **BFS** шляхи: завжди найкоротші з точки зору кількості ребер. BFS досліджує всі вершини на поточному рівні, забезпечуючи, що знайдений шлях є найкоротшим можливим.

# Висновок:
Отже, у незваженому графі для знаходження найкоротшого шляху краще використовувати алгоритм BFS. DFS може бути корисним, коли потрібно дослідити всі можливі шляхи або знайти конкретні шляхи, які не обов’язково є найкоротшими.