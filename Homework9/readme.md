# Порівняння ефективності

## Жадібний алгоритм:
- **Часова складність:** O(n), де n - кількість номіналів монет.
- **Просторова складність:** O(1).
- **Переваги:** швидкість і простота реалізації, особливо ефективний для великих сум при умові, що 
великі номінали можуть покрити більшу частину суми.
- **Недоліки:** не завжди гарантує мінімальну кількість монет для формування суми (може бути 
оптимальний тільки для певних наборів номіналів).

## Алгоритм динамічного програмування:

- **Часова складність:** O(n * amount), де n - кількість номіналів монет, amount - сума, яку 
потрібно видати.
- **Просторова складність:** O(amount).
- **Переваги:** завжди знаходить мінімальну кількість монет, необхідних для формування заданої суми.
- **Недоліки:** більша складність і використання пам’яті в порівнянні з жадібним алгоритмом,
особливо для великих сум.

## Тести
| Amount | Greedy Algorithm (seconds) | Dynamic Programming Algorithm (seconds) |
|--------|-----------------------------|------------------------------------------|
| 113    | 0.0000101250                | 0.0016423750                             |
| 1000   | 0.0000058750                | 0.0155806250                             |
| 5678   | 0.0000090830                | 0.0743446250                             |
| 12345  | 0.0000068750                | 0.1603487920                             |
| 100000 | 0.0000064580                | 1.3664587090                             |

## Висновки

Жадібний алгоритм підходить для швидкого знаходження рішення, якщо номінали монет дозволяють 
ефективно використовувати великі номінали для великих сум. Алгоритм динамічного програмування 
завжди знаходить оптимальне рішення щодо кількості монет, проте має більшу складність і 
використання пам’яті. 

Таким чином, вибір алгоритму залежить від конкретної задачі: якщо 
важлива швидкість, варто використовувати жадібний алгоритм; якщо важлива мінімальна 
кількість монет, варто використовувати алгоритм динамічного програмування.